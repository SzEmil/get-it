generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("POSTGRES_PRISMA_URL")
}

model User {
  id          Int      @id @default(autoincrement())
  clerkId     String   @unique
  email       String   @unique
  photo       String
  firstName   String
  lastName    String
  planId      Int?
  phone       String?  /// @encrypted
  street      String?  /// @encrypted
  houseNumber String?  /// @encrypted
  flatNumber  String?  /// @encrypted
  postalCode  String?  /// @encrypted
  city        String?  /// @encrypted

  payments Payment[]
  courses  Course[]  // Implicit many-to-many relation with Course

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}



model Course {
  id          Int          @id @default(autoincrement())
  courseId    Int
  name        String
  description String
  images      String[]
  language    String       @default("pl")
  status      CourseStatus @default(DRAFT)
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
  videos      Video[]
  Offer       Offer[]
  users       User[]       // Implicit many-to-many relation with User
  lessons     Json          @default("{}")
}

model Video {
  id          Int      @id @default(autoincrement())
  link        String
  description String
  image       String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  courseId    Int
  course      Course   @relation(fields: [courseId], references: [id], onDelete: Cascade)
}

model Payment {
  id               Int           @id @default(autoincrement())
  createdAt        DateTime      @default(now())
  updatedAt        DateTime      @updatedAt
  paymentSessionId String?
  phone            String /// @encrypted
  email            String /// @encrypted
  firstName        String /// @encrypted
  lastName         String /// @encrypted
  address          String @default("") /// @encrypted 
  postalCode       String /// @encrypted
  city             String /// @encrypted
  amount           Float
  currency         String
  paymentStatus    PaymentStatus @default(AWAITING)
  paymentMethod    String?
  userId           Int
  user             User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  courses          OrderCourse[]

  invoice_name      String? 
  invoice_address   String? 
  invoice_postal_code String? 
  invoice_town      String? 
  invoice_country   String? 
  invoice_nip       String?
  invoice_type      InvoiceType @default(PERSONAL)

  invoices         Invoice[]     @relation("PaymentInvoices")
}

model Invoice {
  id               Int           @id @default(autoincrement())
  createdAt        DateTime      @default(now())
  updatedAt        DateTime      @updatedAt


  invoice_number      String  
  seller_name         String    @default("Karol Sapio≈Çko Narevka")
  seller_address      String    @default("Hajnowska 1 A ")
  seller_postalCode   String    @default("17-220")
  seller_town         String    @default("Narewka")
  seller_NIP          String    @default("6030083353")
  seller_REGON        String    @default("527787213")
  seller_code         String    @default("+48")
  seller_phone        String    @default("887600255")   
  seller_country      String    @default("Polska")

  buyer_name          String    
  buyer_address       String    
  buyer_postalCode    String    
  buyer_town          String  
  buyer_NIP           String  
  buyer_country       String

  bank_name           String?    @default("mbank")
  bank_account        String?    @default("661140 2004 0000 3502 7459 8267")
  bank_swift          String?    
 
  price               Float
  currency            String    

  paymentId           Int       
  paymentMethod       String   
  payment_name        String   
  payment_date        DateTime
  sold_date           DateTime
  exchange_rate       Float? 
  exchange_rate_date  DateTime?

  type                InvoiceType

  product_id          Int
  product_name        String

  payment             Payment   @relation("PaymentInvoices", fields: [paymentId], references: [id], onDelete: Cascade)
}

// Definicja enum dla invoice_type
enum InvoiceType {
  PERSONAL
  COMPANY
}
model OrderCourse {
  id         Int      @id @default(autoincrement())
  courseId   Int
  courseName String
  paymentId  Int
  createdAt  DateTime @default(now())
  updatedAt  DateTime @default(now())
  payment    Payment  @relation(fields: [paymentId], references: [id], onDelete: Cascade)
}

model Offer {
  id          Int         @id @default(autoincrement())
  name        String
  description String
  images      String[]
  goals       String[]
  price       Float
  currency    String     @default("PLN")
  language    String      @default("pl")
  tags        String[]
  courseId    Int
  status      OfferStatus @default(DRAFT)
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  course      Course      @relation(fields: [courseId], references: [id], onDelete: Cascade)
}

enum PaymentStatus {
  AWAITING
  SUCCESS
  ERROR
  NO_PAYMENT
  ADVANCE_PAYMENT
  PAYMENT_RETURNED
  FAILED
}

enum CourseStatus {
  ACTIVE
  DRAFT
  CANCELLED
}

enum OfferStatus {
  ACTIVE
  DRAFT
  CANCELLED
}
